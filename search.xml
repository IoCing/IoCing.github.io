<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>levelDB源码阅读</title>
    <url>/2022/08/13/levelDB%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="levelDB-源码阅读"><a href="#levelDB-源码阅读" class="headerlink" title="levelDB 源码阅读"></a>levelDB 源码阅读</h1><p>很久没有写文档了，之前利用hexo+github搞了这个自己的博客，但是一直都没写什么东西，最近在levelDB的代码，我觉得应该写点什么记录一下。我的笔记中可能有错误，我写的东西口语化比较严重，我的表达能力还有待提高。但是写一些笔记主要还是一种记录吧，希望自己能学到更多的东西，如果我写的文档有人觉得有用就更好了，我自己在学习的时候也看了很多其他人写的文档。</p>
<p>关于levelDB的源码阅读，我在看的时候，现在感觉比较复杂的点是versionset，compaction的部分代码比较复杂，但是逻辑上是比较简单的。其他部分主要是levelDB中有许多的文件格式例如SSTable，memtable，log等等。这些我都分别写了笔记。levelDB中也还有一些特性和工具可以研究学习一下，比如他里面的skiplist的实现，内存管理Arena，bloom filter的实现，以及一些编码等等。</p>
<p>目前我还没有完全看完，levelDB的阅读笔记应该会更新一段时间。</p>
<p>目前我最主要的参考对象是两个大佬的博客。在这里列出来，之后的笔记里面就不单独列出了。</p>
<ul>
<li>1.<a href="http://catkang.github.io/2017/01/17/leveldb-data.html">catKang</a></li>
<li>2.<a href="https://youjiali1995.github.io/">我叫尤加利</a></li>
</ul>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB-SSTable</title>
    <url>/2022/08/13/levelDB-SSTable/</url>
    <content><![CDATA[<h1 id="levelDB-SSTable"><a href="#levelDB-SSTable" class="headerlink" title="levelDB-SSTable"></a>levelDB-SSTable</h1><p>sstable是在磁盘的组织文件，每一个level可能有多个sstable，这些table的信息都会存放到version里面，再查找的时候就去当前version名为current里面去查找对应的信息。</p>
<p>下面来研究一下table的组织结构吧，再个catkong大佬的图画的怎么很好啊。再借用一下。</p>
<p><img src="https://iocing-image.oss-cn-shenzhen.aliyuncs.com/img/sst1-20220813145550232.png" alt="sst1"></p>
<p>（图片来源:<a href="http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储</a>)</p>
<p>首先一个table是由footer和多个block组成的，而block也分很多类型。</p>
<h4 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h4><p>首先是footer模块，打开一个table就是从这里开始的，他里面会存放，indexBlock和metaIndexBlock的信息，可以再Table::Open函数实现里面看到，最一开始就是读出footer，然后解码，再根据信息去读indexBlock和metaIndexBlock。</p>
<h4 id="indexBlock"><a href="#indexBlock" class="headerlink" title="indexBlock"></a>indexBlock</h4><p>indexBlock里面存放了每个DataBlock的最后一个key，以及这个Datablock的索引信息，</p>
<h4 id="metaIndexBlock"><a href="#metaIndexBlock" class="headerlink" title="metaIndexBlock"></a>metaIndexBlock</h4><p>保存metaBlock的信息，再levelDB中metaBlock保存的是一个过滤器。metaindex_handle用来保存fliter的offset和size。</p>
<h4 id="DataBlock"><a href="#DataBlock" class="headerlink" title="DataBlock"></a>DataBlock</h4><p>数据块就是再sstable中存放key-value的部分，当前存放的格式会被编码成一个个entry。格式如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">An entry <span class="hljs-keyword">for</span> a particular key-value pair has the form:<br><span class="hljs-comment">//     shared_bytes: varint32</span><br><span class="hljs-comment">//     unshared_bytes: varint32</span><br><span class="hljs-comment">//     value_length: varint32</span><br><span class="hljs-comment">//     key_delta: char[unshared_bytes]</span><br><span class="hljs-comment">//     value: char[value_length]</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p> 当存储一个密钥时，删除了与前一个字符串共享的前缀。 这有助于显着减少空间需求。 此外，每 K 个密钥一次，我们不应用前缀压缩并存储整个密钥。 我们称之为“重启点”。 该块的尾部存储了所有重新开始点的偏移量，并且可以在查找特定键时用于进行二分查找。 值按原样（不压缩）存储在相应键之后。</p>
</blockquote>
<p>上面是代码中的注释，不存储和前面的相同前缀，这样可以减少存储key所需要的空间。</p>
<h4 id="MetaBlock"><a href="#MetaBlock" class="headerlink" title="MetaBlock"></a>MetaBlock</h4><p>levelDB在table中使用bloom filter作为一个元数据的管理。在查找某个key之前先去查一下过滤器，这个key是否存在。在插入数据时也需要向filter中插入信息。这个流程可以再table_builder的add函数中看到。</p>
<p>在levelDB的代码实现中sstable相关的代码可能是最多的，定义了许多的类型。其中最关键的应该就是table和block相关的了吧。</p>
<p>tablebuilder是用来向sstable文件中添加数据，构造各种块的。而table是用来读的，从他们的成员变量和成员函数就也可以看出一些端倪。tabke对外提供了iterator，函数也都是read，和get。而table_build对外提供的方法是add，函数都是writeblock等等。也可以看出他们的定位。</p>
<p>tablebuilder用来做compact的时候会用到，因为是只有compact才会从内存写到磁盘文件，或者再底层的level向高层level去合并。而table是用来进行查找的，再DB的Get实现中会一层一层向下去查找，其中查找到某一个sstable的时候，就需要先Tbale::Open 然后再调用get函数来查找。对应与table和table_builder,关于block的操作也是有读写两种。其中写的操作也都被封装到了block_builder里面，还有一种特殊一点的filter_builder。</p>
<h3 id="table-写入数据"><a href="#table-写入数据" class="headerlink" title="table 写入数据"></a>table 写入数据</h3><p>直接看一下add函数实现</p>
<h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  Rep* r = rep_;<br>  <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//要判断一下key是不是大于当前的lastkey 因为sstable里面应该是有序的</span><br>  <span class="hljs-keyword">if</span> (r-&gt;num_entries &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="hljs-built_in">Compare</span>(key, <span class="hljs-built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//这里应该是代表要不要开一个新块</span><br>  <span class="hljs-keyword">if</span> (r-&gt;pending_index_entry) &#123;<br>    <span class="hljs-built_in">assert</span>(r-&gt;data_block.<span class="hljs-built_in">empty</span>());<br>    r-&gt;options.comparator-&gt;<span class="hljs-built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);<br>    std::string handle_encoding;<br>    r-&gt;pending_handle.<span class="hljs-built_in">EncodeTo</span>(&amp;handle_encoding);<br>    r-&gt;index_block.<span class="hljs-built_in">Add</span>(r-&gt;last_key, <span class="hljs-built_in">Slice</span>(handle_encoding));<br>    r-&gt;pending_index_entry = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//向过滤器里面添加信息 过滤器就是元数据管理</span><br>  <span class="hljs-keyword">if</span> (r-&gt;filter_block != <span class="hljs-literal">nullptr</span>) &#123;<br>    r-&gt;filter_block-&gt;<span class="hljs-built_in">AddKey</span>(key);<br>  &#125;<br><br><br>  r-&gt;last_key.<span class="hljs-built_in">assign</span>(key.<span class="hljs-built_in">data</span>(), key.<span class="hljs-built_in">size</span>());<br>  r-&gt;num_entries++;<br>  r-&gt;data_block.<span class="hljs-built_in">Add</span>(key, value);<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="hljs-built_in">CurrentSizeEstimate</span>();<br>  <span class="hljs-comment">//如果这个块大小不够了 就开一个新的块</span><br>  <span class="hljs-keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;<br>    <span class="hljs-built_in">Flush</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>要添加一个key-value对，首先要判断是否大于当前的last key</li>
<li>判断是否需要一个新的index_block信息，如果需要就添加一条，里面保存datablock的位置和last_key</li>
<li>向filter_block即bloom filter中添加key</li>
<li>更新last_key，num_entries，向data_block中添加数据</li>
<li>最后要判断一下现在的datablock大小是否需要进行flush。如果需要的话就调用flush函数，在其中他会设置pending_index_entry等信息。</li>
</ul>
<h4 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::Flush</span><span class="hljs-params">()</span> </span>&#123;<br>  Rep* r = rep_;<br>  <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (r-&gt;data_block.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">assert</span>(!r-&gt;pending_index_entry);<br>  <span class="hljs-comment">//写block</span><br>  <span class="hljs-built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>()) &#123;<br>    r-&gt;pending_index_entry = <span class="hljs-literal">true</span>;<br>    r-&gt;status = r-&gt;file-&gt;<span class="hljs-built_in">Flush</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (r-&gt;filter_block != <span class="hljs-literal">nullptr</span>) &#123;<br>    r-&gt;filter_block-&gt;<span class="hljs-built_in">StartBlock</span>(r-&gt;offset);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>调用WriteBlock将数据块写入sstable文件</li>
<li>如果成功的话更新当前的pending_index_entry和status</li>
<li>最后要重置一下filter_block的过滤器，因为之后的kv数据要写到洗呢datablock了，而在levelDB里面是一个datablock对应一个filter的。</li>
</ul>
<h4 id="WriteBlock"><a href="#WriteBlock" class="headerlink" title="WriteBlock"></a>WriteBlock</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::WriteBlock</span><span class="hljs-params">(BlockBuilder* block, BlockHandle* handle)</span> </span>&#123;<br>  <span class="hljs-comment">// File format contains a sequence of blocks where each block has:</span><br>  <span class="hljs-comment">//    block_data: uint8[n]</span><br>  <span class="hljs-comment">//    type: uint8</span><br>  <span class="hljs-comment">//    crc: uint32</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">ok</span>());<br>  Rep* r = rep_;<br>  Slice raw = block-&gt;<span class="hljs-built_in">Finish</span>();<br><br>  Slice block_contents;<br>  CompressionType type = r-&gt;options.compression;<br>  <span class="hljs-comment">// TODO(postrelease): Support more compression options: zlib?</span><br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> kNoCompression:<br>      block_contents = raw;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> kSnappyCompression: &#123;<br>      std::string* compressed = &amp;r-&gt;compressed_output;<br>      <span class="hljs-keyword">if</span> (port::<span class="hljs-built_in">Snappy_Compress</span>(raw.<span class="hljs-built_in">data</span>(), raw.<span class="hljs-built_in">size</span>(), compressed) &amp;&amp;<br>          compressed-&gt;<span class="hljs-built_in">size</span>() &lt; raw.<span class="hljs-built_in">size</span>() - (raw.<span class="hljs-built_in">size</span>() / <span class="hljs-number">8u</span>)) &#123;<br>        block_contents = *compressed;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Snappy not supported, or compressed less than 12.5%, so just</span><br>        <span class="hljs-comment">// store uncompressed form</span><br>        block_contents = raw;<br>        type = kNoCompression;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">WriteRawBlock</span>(block_contents, type, handle);<br>  r-&gt;compressed_output.<span class="hljs-built_in">clear</span>();<br>  block-&gt;<span class="hljs-built_in">Reset</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先调用block-&gt;Finish()让当前Block停用，然后返回要保存的额内容</li>
<li>之后要根据压缩策略来获取到最终写入sstable的block_contents。</li>
<li>调用WriteRawBlock 将block_contents写入文件</li>
<li>reset 当前的datablock。(原来其实一直都是用的一个实例)</li>
</ul>
<h4 id="WriteRawBlock"><a href="#WriteRawBlock" class="headerlink" title="WriteRawBlock"></a>WriteRawBlock</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::WriteRawBlock</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; block_contents,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;<br>  Rep* r = rep_;<br>  handle-&gt;<span class="hljs-built_in">set_offset</span>(r-&gt;offset);<br>  handle-&gt;<span class="hljs-built_in">set_size</span>(block_contents.<span class="hljs-built_in">size</span>());<br>  r-&gt;status = r-&gt;file-&gt;<span class="hljs-built_in">Append</span>(block_contents);<br>  <span class="hljs-keyword">if</span> (r-&gt;status.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-type">char</span> trailer[kBlockTrailerSize];<br>    trailer[<span class="hljs-number">0</span>] = type;<br>    <span class="hljs-type">uint32_t</span> crc = crc32c::<span class="hljs-built_in">Value</span>(block_contents.<span class="hljs-built_in">data</span>(), block_contents.<span class="hljs-built_in">size</span>());<br>    crc = crc32c::<span class="hljs-built_in">Extend</span>(crc, trailer, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Extend crc to cover block type</span><br>    <span class="hljs-built_in">EncodeFixed32</span>(trailer + <span class="hljs-number">1</span>, crc32c::<span class="hljs-built_in">Mask</span>(crc));<br>    r-&gt;status = r-&gt;file-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(trailer, kBlockTrailerSize));<br>    <span class="hljs-keyword">if</span> (r-&gt;status.<span class="hljs-built_in">ok</span>()) &#123;<br>      r-&gt;offset += block_contents.<span class="hljs-built_in">size</span>() + kBlockTrailerSize;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后就是WriteRawBlock了，这个的过程很简单了，就是先Append(block_contents)，然后计算出crc以后再把CompressionType和crc写入到文件就可以了。最后更新一下offset。</p>
<p>到这里在table层面的写入流程就写完了，但其实可以发现，再table层还是调用了不少block层面的额函数。之后看一下block的写入流程。</p>
<h3 id="block的写入流程"><a href="#block的写入流程" class="headerlink" title="block的写入流程"></a>block的写入流程</h3><p>block的写入就是要将key-value数据写进当前的块中，逻辑是比较简单的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BlockBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  <span class="hljs-function">Slice <span class="hljs-title">last_key_piece</span><span class="hljs-params">(last_key_)</span></span>;<br>  <span class="hljs-built_in">assert</span>(!finished_);<br>  <span class="hljs-built_in">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);<br>  <span class="hljs-built_in">assert</span>(buffer_.<span class="hljs-built_in">empty</span>()  <span class="hljs-comment">// No values yet?</span><br>         || options_-&gt;comparator-&gt;<span class="hljs-built_in">Compare</span>(key, last_key_piece) &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-type">size_t</span> shared = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;<br>    <span class="hljs-comment">// See how much sharing to do with previous string</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> min_length = std::<span class="hljs-built_in">min</span>(last_key_piece.<span class="hljs-built_in">size</span>(), key.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;<br>      shared++;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Restart compression</span><br>    restarts_.<span class="hljs-built_in">push_back</span>(buffer_.<span class="hljs-built_in">size</span>());<br>    counter_ = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> non_shared = key.<span class="hljs-built_in">size</span>() - shared;<br><br>  <span class="hljs-comment">// Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_</span><br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, shared);<br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, non_shared);<br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, value.<span class="hljs-built_in">size</span>());<br><br>  <span class="hljs-comment">// Add string delta to buffer_ followed by value</span><br>  buffer_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>  buffer_.<span class="hljs-built_in">append</span>(value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">size</span>());<br><br>  <span class="hljs-comment">// Update state</span><br>  last_key_.<span class="hljs-built_in">resize</span>(shared);<br>  last_key_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">Slice</span>(last_key_) == key);<br>  counter_++;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先要处理key值，这个之前介绍过，再block中存放key值会省略掉前缀，这样就需要保持前面key的记录，为了让由于前面记录丢失造成影响较小。levelDB中设置个几个key就设置一个重启点，在这个点要存放完整的key。block_restart_interval中记录了每个隔断的长度，这个是在options中可以设置的。</li>
<li>然后就很简单了直接按照entry的格式，将数据都append到buffer中</li>
<li>最后更新一下状态。</li>
</ul>
<p>在block_builder中的方法比较少，其他的finish，reset不再赘述了。</p>
<p>SSTable的读取的流程我准备在DBimpl中的读取流程来整体的写一下。在这个文档中重点关注了table，block的组织结构和写入的流程。levelDB这部分的代码比较简洁，也比较容易看懂，要多学习大佬的代码风格。。</p>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB-Compaction</title>
    <url>/2022/08/13/levelDB-Compaction/</url>
    <content><![CDATA[<h1 id="levelDB-Compaction"><a href="#levelDB-Compaction" class="headerlink" title="levelDB-Compaction"></a>levelDB-Compaction</h1><p>看了一些博客，也看了一些代码，在levelDB中将Compact的处理分为两种，分别是Memtable Compaction和SStable Compaction。下面就介绍一下两种compaction的流程和具体实现。个人能力有限，可能会有一些有误的地方。</p>
<h3 id="Memtable-Compaction"><a href="#Memtable-Compaction" class="headerlink" title="Memtable Compaction"></a>Memtable Compaction</h3><p>levelDB中的写数据都是直接写到memtable中，在memtable的容量超过一个阈值时，就需要进行压缩了，这里的这个阈值在options_.write_buffer_size中设置，默认是4MB。write中会调用MakeRoomForWrite，在写数据之前申请空间。当发现memtable空间不够时会触发memtable compaction。</p>
<h4 id="MakeRoomForWrite"><a href="#MakeRoomForWrite" class="headerlink" title="MakeRoomForWrite"></a>MakeRoomForWrite</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// REQUIRES: mutex_ is held</span><br><span class="hljs-comment">// REQUIRES: this thread is currently at the front of the writer queue</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::MakeRoomForWrite</span><span class="hljs-params">(<span class="hljs-type">bool</span> force)</span> </span>&#123;<br>  mutex_.<span class="hljs-built_in">AssertHeld</span>();<br>  <span class="hljs-built_in">assert</span>(!writers_.<span class="hljs-built_in">empty</span>());<br>  <span class="hljs-type">bool</span> allow_delay = !force;<br>  Status s;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!bg_error_.<span class="hljs-built_in">ok</span>()) &#123;<br>      <span class="hljs-comment">// Yield previous error</span><br>      s = bg_error_;<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;<span class="hljs-built_in">NumLevelFiles</span>(<span class="hljs-number">0</span>) &gt;=<br>                                  config::kL0_SlowdownWritesTrigger) &#123;<br>      <span class="hljs-comment">// We are getting close to hitting a hard limit on the number of</span><br>      <span class="hljs-comment">// L0 files.  Rather than delaying a single write by several</span><br>      <span class="hljs-comment">// seconds when we hit the hard limit, start delaying each</span><br>      <span class="hljs-comment">// individual write by 1ms to reduce latency variance.  Also,</span><br>      <span class="hljs-comment">// this delay hands over some CPU to the compaction thread in</span><br>      <span class="hljs-comment">// case it is sharing the same core as the writer.</span><br>      mutex_.<span class="hljs-built_in">Unlock</span>();<br>      env_-&gt;<span class="hljs-built_in">SleepForMicroseconds</span>(<span class="hljs-number">1000</span>);<br>      allow_delay = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Do not delay a single write more than once</span><br>      mutex_.<span class="hljs-built_in">Lock</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!force &amp;&amp;<br>               (mem_-&gt;<span class="hljs-built_in">ApproximateMemoryUsage</span>() &lt;= options_.write_buffer_size)) &#123;<br>      <span class="hljs-comment">// There is room in current memtable</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imm_ != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-comment">// We have filled up the current memtable, but the previous</span><br>      <span class="hljs-comment">// one is still being compacted, so we wait.</span><br>      <span class="hljs-built_in">Log</span>(options_.info_log, <span class="hljs-string">&quot;Current memtable full; waiting...\n&quot;</span>);<br>      background_work_finished_signal_.<span class="hljs-built_in">Wait</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (versions_-&gt;<span class="hljs-built_in">NumLevelFiles</span>(<span class="hljs-number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;<br>      <span class="hljs-comment">// There are too many level-0 files.</span><br>      <span class="hljs-built_in">Log</span>(options_.info_log, <span class="hljs-string">&quot;Too many L0 files; waiting...\n&quot;</span>);<br>      background_work_finished_signal_.<span class="hljs-built_in">Wait</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Attempt to switch to a new memtable and trigger compaction of old</span><br>      <span class="hljs-built_in">assert</span>(versions_-&gt;<span class="hljs-built_in">PrevLogNumber</span>() == <span class="hljs-number">0</span>);<br>      <span class="hljs-type">uint64_t</span> new_log_number = versions_-&gt;<span class="hljs-built_in">NewFileNumber</span>();<br>      WritableFile* lfile = <span class="hljs-literal">nullptr</span>;<br>      s = env_-&gt;<span class="hljs-built_in">NewWritableFile</span>(<span class="hljs-built_in">LogFileName</span>(dbname_, new_log_number), &amp;lfile);<br>      <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-comment">// Avoid chewing through file number space in a tight loop.</span><br>        versions_-&gt;<span class="hljs-built_in">ReuseFileNumber</span>(new_log_number);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">delete</span> log_;<br>      <span class="hljs-keyword">delete</span> logfile_;<br>      logfile_ = lfile;<br>      logfile_number_ = new_log_number;<br>      log_ = <span class="hljs-keyword">new</span> log::<span class="hljs-built_in">Writer</span>(lfile);<br>      imm_ = mem_;<br>      has_imm_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">true</span>, std::memory_order_release);<br>      mem_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MemTable</span>(internal_comparator_);<br>      mem_-&gt;<span class="hljs-built_in">Ref</span>();<br>      force = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Do not force another compaction if have room</span><br>      <span class="hljs-built_in">MaybeScheduleCompaction</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数是用来申请空间的，直到在memtable中可以获得空间才会退出。</p>
<ul>
<li>判断L0层的文件数是否超过了kL0_StopWritesTrigger，这时如果allow_delay可以先睡眠1s。之后再操作。最多可以delay一次</li>
<li>第二个判断中，如果当前memtable是有空间的那么就直接返回</li>
<li>在第三个判断中，我们当前memtable说明没有足够空间了，那么说明需要一个新的memtable，并且将旧的memtable转化为immemtable，但是这时我们已经有一个immemtable了，那么就需要等immemtable持久化到level0以后，将imm置为nullptr才能继续向下进行。这里使用了一个条件变量</li>
<li>在第四个判断中，我们可以进行转化了，但是l0层文件数太多，也需要进行一次等待。</li>
<li>最后的判断中，说明满足了一切条件，我们可以将当前的memtable转化为immemtable，然后创建一个新的memtable。最后还要调用一下MaybeScheduleCompaction，这里发现imm不为空的话，会将immemtable写到l0层，然后将imm设置为nullptr。</li>
</ul>
<h4 id="CompactMemTable"><a href="#CompactMemTable" class="headerlink" title="CompactMemTable"></a>CompactMemTable</h4><p>将immemtable持久化到l0就是在这个函数中作处理的。下面是具体的代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DBImpl::CompactMemTable</span><span class="hljs-params">()</span> </span>&#123;<br>  mutex_.<span class="hljs-built_in">AssertHeld</span>();<br>  <span class="hljs-built_in">assert</span>(imm_ != <span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-comment">// Save the contents of the memtable as a new Table</span><br>  VersionEdit edit;<br>  Version* base = versions_-&gt;<span class="hljs-built_in">current</span>();<br>  base-&gt;<span class="hljs-built_in">Ref</span>();<br>  Status s = <span class="hljs-built_in">WriteLevel0Table</span>(imm_, &amp;edit, base);<br>  base-&gt;<span class="hljs-built_in">Unref</span>();<br><br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>() &amp;&amp; shutting_down_.<span class="hljs-built_in">load</span>(std::memory_order_acquire)) &#123;<br>    s = Status::<span class="hljs-built_in">IOError</span>(<span class="hljs-string">&quot;Deleting DB during memtable compaction&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Replace immutable memtable with the generated Table</span><br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    edit.<span class="hljs-built_in">SetPrevLogNumber</span>(<span class="hljs-number">0</span>);<br>    edit.<span class="hljs-built_in">SetLogNumber</span>(logfile_number_);  <span class="hljs-comment">// Earlier logs no longer needed</span><br>    s = versions_-&gt;<span class="hljs-built_in">LogAndApply</span>(&amp;edit, &amp;mutex_);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// Commit to the new state</span><br>    imm_-&gt;<span class="hljs-built_in">Unref</span>();<br>    imm_ = <span class="hljs-literal">nullptr</span>;<br>    has_imm_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">false</span>, std::memory_order_release);<br>    <span class="hljs-built_in">RemoveObsoleteFiles</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">RecordBackgroundError</span>(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>获取当前的version保存到base中</li>
<li>将imm中的数据写到level0的table中，调用WriteLevel0Table实现，并且生成一个VersionEdit。</li>
<li>如果s.ok，就将edit应用到versions_中</li>
<li>最后将imm置为nullptr，调用RemoveObsoleteFiles删除不需要的文件。</li>
</ul>
<p>具体如何写到l0里面的细节不在这里写了，到这里memtable compaction的流程就写完了，主要的目的就是将memtable写到l0层的sstable中。</p>
<h3 id="SSTable-Compaction"><a href="#SSTable-Compaction" class="headerlink" title="SSTable Compaction"></a>SSTable Compaction</h3><p>下面来看一下SSTable的流程，compaction会运行在一个后台的线程中。在官方的文档中有写，压缩流程是当级别 L 的大小超过其限制时，压缩从级别 L 中选择一个文件，并从下一个级别 L+1 中选择所有重叠的文件。如果 level-L 文件仅与 level-(L+1) 文件的一部分重叠，则 level-(L+1) 处的整个文件将用作压缩的输入，并将在压缩后丢弃。另外：因为 level-0 是特殊的（其中的文件可能相互重叠），我们特别对待从 level-0 到 level-1 的压缩：一个 level-0 压缩可能会选择多个 level-0 文件，以防其中一些文件文件相互重叠。压缩合并挑选的文件的内容以产生一系列level-(L+1) 文件。在当前输出文件达到目标文件大小（2MB）后，我们切换到生成新的（L+1）级文件。当当前输出文件的键范围增长到足以与十多个级别（L+2）文件重叠时，我们也会切换到新的输出文件。最后一条规则确保稍后对 level-(L+1) 文件的压缩不会从 level-(L+2) 中提取太多数据。旧文件被丢弃，新文件被添加到服务状态。压缩删除覆盖的值。如果没有更高编号的级别包含范围与当前键重叠的文件，它们也会删除删除标记。</p>
<p>上面是直接翻译了官方文档，下面结合代码来写一些我自己的理解。</p>
<h4 id="MaybeScheduleCompaction"><a href="#MaybeScheduleCompaction" class="headerlink" title="MaybeScheduleCompaction"></a>MaybeScheduleCompaction</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DBImpl::MaybeScheduleCompaction</span><span class="hljs-params">()</span> </span>&#123;<br>  mutex_.<span class="hljs-built_in">AssertHeld</span>();<br>  <span class="hljs-keyword">if</span> (background_compaction_scheduled_) &#123;<br>    <span class="hljs-comment">// Already scheduled</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shutting_down_.<span class="hljs-built_in">load</span>(std::memory_order_acquire)) &#123;<br>    <span class="hljs-comment">// DB is being deleted; no more background compactions</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!bg_error_.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// Already got an error; no more changes</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imm_ == <span class="hljs-literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="hljs-literal">nullptr</span> &amp;&amp;<br>             !versions_-&gt;<span class="hljs-built_in">NeedsCompaction</span>()) &#123;<br>    <span class="hljs-comment">// No work to be done</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    background_compaction_scheduled_ = <span class="hljs-literal">true</span>;<br>    env_-&gt;<span class="hljs-built_in">Schedule</span>(&amp;DBImpl::BGWork, <span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>MaybeScheduleCompaction函数是开启compact的入口。</p>
<ul>
<li>如果当前已经开启background_compaction_scheduled_，后台的压缩线程，那么就跳过</li>
<li>判断如果当前DB已经shutdown或者有error就跳过</li>
<li>判断没有需要进行compact的部分就跳过</li>
<li>最后在经过上面一些判断以后，需要进行compaction的话，将background_compaction_scheduled_置为true，然后env_-&gt;Schedule(&amp;DBImpl::BGWork, this)是在后台开启一个线程，函数是BGWork，参数是this指向当前的DB。</li>
</ul>
<h4 id="BackgroundCall"><a href="#BackgroundCall" class="headerlink" title="BackgroundCall"></a>BackgroundCall</h4><p>这个函数是在后台做一个逻辑上的处理，判断如果条件满足的话就调用BackgroundCompaction开启一次真正的compaction，虽然将Compaction分成了两种，但是其实都是在BackgroundCompaction中作处理的。</p>
<p>在做完一次压缩以后，因为可能给下一层的文件增加的文件使下一层的文件数超出阈值，这时再调用一次MaybeScheduleCompaction，如果有需要的话会继续进行compact。</p>
<p>最后结束了全部的压缩，唤醒background_work_finished_signal_条件变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DBImpl::BackgroundCall</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>  <span class="hljs-built_in">assert</span>(background_compaction_scheduled_);<br>  <span class="hljs-keyword">if</span> (shutting_down_.<span class="hljs-built_in">load</span>(std::memory_order_acquire)) &#123;<br>    <span class="hljs-comment">// No more background work when shutting down.</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!bg_error_.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// No more background work after a background error.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">BackgroundCompaction</span>();<br>  &#125;<br><br>  background_compaction_scheduled_ = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Previous compaction may have produced too many files in a level,</span><br>  <span class="hljs-comment">// so reschedule another compaction if needed.</span><br>  <span class="hljs-built_in">MaybeScheduleCompaction</span>();<br>  background_work_finished_signal_.<span class="hljs-built_in">SignalAll</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="BackgroundCompaction"><a href="#BackgroundCompaction" class="headerlink" title="BackgroundCompaction"></a>BackgroundCompaction</h4><p>这里就是compaction的最核心的函数了，代码逻辑也是比较复杂的，仔细研究一下。</p>
<p>看的有点头疼，感觉太复杂了，短时间看不明白呢，，，，</p>
<p>这个先放一放吧，整体的逻辑是明白了，但是细节实现还得再看看。</p>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB-Arena</title>
    <url>/2022/08/13/levelDB-Arena/</url>
    <content><![CDATA[<h1 id="levelDB-Arena-内存管理"><a href="#levelDB-Arena-内存管理" class="headerlink" title="levelDB-Arena 内存管理"></a>levelDB-Arena 内存管理</h1><p>在levelDB中自己实现了对内存的管理，主要功能是申请内存中的块，在析构函数中会将所有申请到的块进行删除，这样可以防止内存泄漏。</p>
<p>Arena默认的内存块大小为4KB，如果超出了1KB就按照bytes所需要的大小来进行分配。</p>
<p>Arena的代码实现逻辑比较简单，可以很快的看懂。Arena内部有四个成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* alloc_ptr_; <span class="hljs-comment">//当前block中空闲区域的起始位置</span><br><br><span class="hljs-type">size_t</span> alloc_bytes_remaining_;<span class="hljs-comment">//当前block中可分配的剩余的位置</span><br><br><span class="hljs-comment">// Array of new[] allocated memory blocks</span><br>std::vector&lt;<span class="hljs-type">char</span>*&gt; blocks_; <span class="hljs-comment">//记录所有申请的内存块</span><br><br>std::atomic&lt;<span class="hljs-type">size_t</span>&gt; memory_usage_;<span class="hljs-comment">//记录已占用内存的大小</span><br></code></pre></td></tr></table></figure>

<p>Arena对外提供两个方法赖申请内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br><br><span class="hljs-comment">// Allocate memory with the normal alignment guarantees provided by malloc.</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocateAligned</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br></code></pre></td></tr></table></figure>

<p>AllocateAligned与Allocate不同之处在于申请的空间会进行对齐。</p>
<h3 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h3><p>Allocate申请bytes大小的区域，如果当前块有足够区域，就直接返回指针，并且将alloc_ptr_，alloc_bytes_remaining_更新。</p>
<p>如果当前块剩余空间不足的话就需要申请新的块了，调用AllocateFallback函数做进一步处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span>* <span class="hljs-title">Arena::Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span> </span>&#123;<br>  <span class="hljs-comment">// The semantics of what to return are a bit messy if we allow</span><br>  <span class="hljs-comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span><br>  <span class="hljs-comment">// them for our internal use).</span><br>  <span class="hljs-built_in">assert</span>(bytes &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;<br>    <span class="hljs-type">char</span>* result = alloc_ptr_;<br>    alloc_ptr_ += bytes;<br>    alloc_bytes_remaining_ -= bytes;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AllocateAligned"><a href="#AllocateAligned" class="headerlink" title="AllocateAligned"></a>AllocateAligned</h3><p>AllocateAligned在申请之前要计算一个额外的长度来进行对其，之后得到needed作为需要申请的长度，处理的流程就和Allocate一样了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Arena::AllocateAligned</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> align = (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) &gt; <span class="hljs-number">8</span>) ? <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) : <span class="hljs-number">8</span>;<br>  <span class="hljs-built_in">static_assert</span>((align &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>,<br>                <span class="hljs-string">&quot;Pointer size should be a power of 2&quot;</span>);<br>  <span class="hljs-type">size_t</span> current_mod = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="hljs-number">1</span>);<br>  <span class="hljs-type">size_t</span> slop = (current_mod == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : align - current_mod);<br>  <span class="hljs-type">size_t</span> needed = bytes + slop;<br>  <span class="hljs-type">char</span>* result;<br>  <span class="hljs-keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;<br>    result = alloc_ptr_ + slop;<br>    alloc_ptr_ += needed;<br>    alloc_bytes_remaining_ -= needed;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// AllocateFallback always returned aligned memory</span><br>    result = <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>  &#125;<br>  <span class="hljs-built_in">assert</span>((<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(result) &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="AllocateNewBlock"><a href="#AllocateNewBlock" class="headerlink" title="AllocateNewBlock"></a>AllocateNewBlock</h3><p>AllocateNewBlock函数是用来申请一个块，然后将它添加到blocks_中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Arena::AllocateNewBlock</span><span class="hljs-params">(<span class="hljs-type">size_t</span> block_bytes)</span> </span>&#123;<br>  <span class="hljs-type">char</span>* result = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[block_bytes];<br>  blocks_.<span class="hljs-built_in">push_back</span>(result);<br>  memory_usage_.<span class="hljs-built_in">fetch_add</span>(block_bytes + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*),<br>                          std::memory_order_relaxed);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AllocateFallback"><a href="#AllocateFallback" class="headerlink" title="AllocateFallback"></a>AllocateFallback</h3><p>这个函数是用来处理块申请的流程的</p>
<p>如果要申请的区域大于kBlockSize &#x2F; 4，这里是1MB的话，就给他申请一个他需要大小的块，可以不浪费剩余字节中的空间。（如果bytes太接近kBlockSize，那么剩下的空间太小可能啥也放不进去了，就浪费掉了）</p>
<p>如果小于1M，就申请一个kBlockSize大小的空间，并且更新一下__alloc_ptr___，和__alloc_bytes_remaining___</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Arena::AllocateFallback</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (bytes &gt; kBlockSize / <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-comment">// Object is more than a quarter of our block size.  Allocate it separately</span><br>    <span class="hljs-comment">// to avoid wasting too much space in leftover bytes.</span><br>    <span class="hljs-type">char</span>* result = <span class="hljs-built_in">AllocateNewBlock</span>(bytes);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// We waste the remaining space in the current block.</span><br>  alloc_ptr_ = <span class="hljs-built_in">AllocateNewBlock</span>(kBlockSize);<br>  alloc_bytes_remaining_ = kBlockSize;<br><br>  <span class="hljs-type">char</span>* result = alloc_ptr_;<br>  alloc_ptr_ += bytes;<br>  alloc_bytes_remaining_ -= bytes;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>到这里关于Arena的实现就写完了，还是比较简单，代码行数也不多。</p>
<p>Arena主要在Memtable和skiplist中使用，当然一个Memtable对应一个skiplist，他们使用的是一个arena实例。</p>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB-MemTable</title>
    <url>/2022/08/13/levelDB-MemTable/</url>
    <content><![CDATA[<h1 id="levelDB-Memtable-and-Immemtable"><a href="#levelDB-Memtable-and-Immemtable" class="headerlink" title="levelDB-Memtable and Immemtable"></a>levelDB-Memtable and Immemtable</h1><h2 id="Memtable"><a href="#Memtable" class="headerlink" title="Memtable"></a>Memtable</h2><p>下面来看一下Memtable的实现和使用流程。</p>
<p>Memtable的内部是一个Skiplist的实现和一个内存管理Arena的部分。</p>
<blockquote>
<p>– 关于key的编码之后仔细在总结一下吧，现在先不关注</p>
</blockquote>
<p>Memtable使用引用计数，如果一个Memtable没有被引用了就将自己delete</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Increase reference count.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">()</span> </span>&#123; ++refs_; &#125;<br><br><span class="hljs-comment">// Drop reference count.  Delete if no more references exist.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unref</span><span class="hljs-params">()</span> </span>&#123;<br>  --refs_;<br>  <span class="hljs-built_in">assert</span>(refs_ &gt;= <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (refs_ &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Memtable有最主要的功能的方法是ADD和Get，以及返回一个Memtable iterator</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Add an entry into memtable that maps key to value at the</span><br><span class="hljs-comment">// specified sequence number and with the specified type.</span><br><span class="hljs-comment">// Typically value will be empty if type==kTypeDeletion.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(SequenceNumber seq, ValueType type, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">         <span class="hljs-type">const</span> Slice&amp; value)</span></span>;<br><br><span class="hljs-comment">// If memtable contains a value for key, store it in *value and return true.</span><br><span class="hljs-comment">// If memtable contains a deletion for key, store a NotFound() error</span><br><span class="hljs-comment">// in *status and return true.</span><br><span class="hljs-comment">// Else, return false.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span></span>;<br><br><span class="hljs-comment">// Return an iterator that yields the contents of the memtable.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The caller must ensure that the underlying MemTable remains live</span><br>  <span class="hljs-comment">// while the returned iterator is live.  The keys returned by this</span><br>  <span class="hljs-comment">// iterator are internal keys encoded by AppendInternalKey in the</span><br>  <span class="hljs-comment">// db/format.&#123;h,cc&#125; module.</span><br>  <span class="hljs-function">Iterator* <span class="hljs-title">NewIterator</span><span class="hljs-params">()</span></span>;<br><br></code></pre></td></tr></table></figure>

<p>其中add的实现中是将key和value编码以后存入到skiplist中。</p>
<p>Get是在skiplist使用memtable key进行搜索，如果找到对应的value并且不是删除标记就返回。</p>
<p>levelDB设置了很多的Iterator，在Memtable iterator的实现中，各种iterator的操作都是封装了底层的skiplist中的iterator方法实现的。这吗多层的封装使上层可以不用关注下层实现的细节。</p>
<p>因为在Mentable中是直接使用skiplist做操作，所以代码逻辑也比较简单。之后应该看一下skiplist的实现。</p>
<h2 id="Immemtable"><a href="#Immemtable" class="headerlink" title="Immemtable"></a>Immemtable</h2><p>本质上immemtabke就是一个memtable，当一个memtable的容量不够的时候，就需要创建一个新的memtable，这时就会将旧的memtable直接转化为immemtable，immemtable还会待在内存中，之后会被compact到磁盘的SStable中，他是只读的。在DB::Get中，如果在memtable中没有查找成功，那么就会从immemtable中进行查找。再往下就是磁盘中的多层的SSTable。</p>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB-Log</title>
    <url>/2022/08/13/levelDB-Log/</url>
    <content><![CDATA[<h1 id="levelDB-Log"><a href="#levelDB-Log" class="headerlink" title="levelDB-Log"></a>levelDB-Log</h1><p>levelDB中的log用来存放写操作的日志，向log中写日志试用log空间中的writer，在leveldb中有不止一个writer，需要进行区分。先来研究一下log_writer的操作，之后在整体db_impl实现中在看一下log的具体的使用逻辑。</p>
<p>关于log的操作还有一个log_reader是用来从log文件中读取记录，这个是在recover的时候会用到，在重新启动一个db的时候会使用。</p>
<p>log_writer和log_reader还被使用于manifest文件的管理，里面存放的是versionedit记录。</p>
<p><img src="https://iocing-image.oss-cn-shenzhen.aliyuncs.com/img/log_format-20220813150002343.png" alt="log_format"></p>
<p>（图片来源:<a href="http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储</a>)</p>
<p>上图展示的是在log中的组织结构，log由多个record组成，每个record的大小可能不同，但是log会被分成一个个大小相同 的block，一个record可能要占多个block，一个block中也可能可以存放多个record。（这里说的有点啰嗦，，，）</p>
<p>可以来看一下log_writer代码中写record的操作，写一下我的理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Record := Header + Content<br>Header := Checksum + Length + Type<br>Type := Full <span class="hljs-keyword">or</span> First <span class="hljs-keyword">or</span> Midder <span class="hljs-keyword">or</span> Last <span class="hljs-comment">//用来区分这个record现在的位置</span><br></code></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>一个record会存放到slice中，他的结构先不用管，是一个编码以后的字符串。</li>
</ol>
</li>
<li><ol start="2">
<li>要获取到他的长度存到left变量中，然后要在一个循环中进行处理，主要是因为可能一次没办法都存上，因为当前block剩余空间可能不够了，得开一个新的block。</li>
</ol>
</li>
<li><ol start="3">
<li>进入循环以后先判断一下现在剩余空间有多少存到leftover里main，如果发现leftcover已经没办法存一个header了，那么说明他这块剩余部分没办法用了。直接开一个新块。</li>
</ol>
</li>
<li><ol start="4">
<li>计算当前block可以存放的数据大小存放到avail里面，如果left是小鱼avail的，那么说明当前block可以一次存下这部分数据，那么fragment_length就设为left。但是如果left超过了avail，说明left-avail的数据需要存到之后的block中，fragment_length就设为avail。</li>
</ol>
</li>
<li><ol start="5">
<li>要根据当前位置设置一下type。</li>
</ol>
</li>
<li><ol start="6">
<li>之后调用EmitPhysicalRecord函数将数据存放到磁盘上，然后更新ptr位置，和left大小。如果符合条件，还需要进行下一轮循环。</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Writer::AddRecord</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; slice)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = slice.<span class="hljs-built_in">data</span>();<br>  <span class="hljs-type">size_t</span> left = slice.<span class="hljs-built_in">size</span>();<br>  Status s;<br>  <span class="hljs-type">bool</span> begin = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> leftover = kBlockSize - block_offset_;<br>    <span class="hljs-built_in">assert</span>(leftover &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (leftover &lt; kHeaderSize) &#123;<br>      <span class="hljs-comment">// Switch to a new block</span><br>      <span class="hljs-keyword">if</span> (leftover &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span><br>        <span class="hljs-built_in">static_assert</span>(kHeaderSize == <span class="hljs-number">7</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(<span class="hljs-string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));<br>      &#125;<br>      block_offset_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;<br><br>    RecordType type;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> end = (left == fragment_length);<br>    <span class="hljs-keyword">if</span> (begin &amp;&amp; end) &#123;<br>      type = kFullType;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (begin) &#123;<br>      type = kFirstType;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end) &#123;<br>      type = kLastType;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      type = kMiddleType;<br>    &#125;<br><br>    s = <span class="hljs-built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);<br>    ptr += fragment_length;<br>    left -= fragment_length;<br>    begin = <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">ok</span>() &amp;&amp; left &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Log_reader中感觉比log_writer要复杂很多，先不看了。。整体的逻辑是明白了，细节先不深究。</p>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB-Write</title>
    <url>/2022/08/13/levelDB-Write/</url>
    <content><![CDATA[<h1 id="levelDB-write"><a href="#levelDB-write" class="headerlink" title="levelDB-write"></a>levelDB-write</h1><p>levelDB中的写操作分为两种，Put和Delete。</p>
<p>但是其实处理是一样的，Put是插入key和value，delete是插入key和删除标记。因为levelDB是分层遍历的，所以在读到删除标记的时候就可以返回。不过levelDB也提供了Snapshot，可以设置读到某个节点之前的数据。</p>
<p>levelDB中write是通过write_batch实现的。write_batch也可以将一部分写操作原子化。</p>
<p>我们在看write的流程前先看一下write_batch的实现吧</p>
<h3 id="write-batch"><a href="#write-batch" class="headerlink" title="write_batch"></a>write_batch</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> WriteBatch &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Handler &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Handler</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Put</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key)</span> </span>= <span class="hljs-number">0</span>;<br>  &#125;;<br><br>  <span class="hljs-built_in">WriteBatch</span>();<br><br>  <span class="hljs-comment">// Intentionally copyable.</span><br>  <span class="hljs-built_in">WriteBatch</span>(<span class="hljs-type">const</span> WriteBatch&amp;) = <span class="hljs-keyword">default</span>;<br>  WriteBatch&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> WriteBatch&amp;) = <span class="hljs-keyword">default</span>;<br><br>  ~<span class="hljs-built_in">WriteBatch</span>();<br><br>  <span class="hljs-comment">// Store the mapping &quot;key-&gt;value&quot; in the database.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Put</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span></span>;<br><br>  <span class="hljs-comment">// If the database contains a mapping for &quot;key&quot;, erase it.  Else do nothing.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key)</span></span>;<br><br>  <span class="hljs-comment">// Clear all updates buffered in this batch.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// The size of the database changes caused by this batch.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This number is tied to implementation details, and may change across</span><br>  <span class="hljs-comment">// releases. It is intended for LevelDB usage metrics.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ApproximateSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Copies the operations in &quot;source&quot; to this batch.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This runs in O(source size) time. However, the constant factor is better</span><br>  <span class="hljs-comment">// than calling Iterate() over the source batch with a Handler that replicates</span><br>  <span class="hljs-comment">// the operations into this batch.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Append</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteBatch&amp; source)</span></span>;<br><br>  <span class="hljs-comment">// Support for iterating over the contents of a batch.</span><br>  <span class="hljs-function">Status <span class="hljs-title">Iterate</span><span class="hljs-params">(Handler* handler)</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteBatchInternal</span>;<br><br>  std::string rep_;  <span class="hljs-comment">// See comment in write_batch.cc for the format of rep_</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>write_batch中只有一个变量就是rep_，他里面存放了所有要put或者delete的信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// WriteBatch::rep_ :=</span><br><span class="hljs-comment">//    sequence: fixed64</span><br><span class="hljs-comment">//    count: fixed32</span><br><span class="hljs-comment">//    data: record[count]</span><br><span class="hljs-comment">// record :=</span><br><span class="hljs-comment">//    kTypeValue varstring varstring         |</span><br><span class="hljs-comment">//    kTypeDeletion varstring</span><br><span class="hljs-comment">// varstring :=</span><br><span class="hljs-comment">//    len: varint32</span><br><span class="hljs-comment">//    data: uint8[len]</span><br></code></pre></td></tr></table></figure>

<p>这是rep的存放结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteBatch::Put</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  WriteBatchInternal::<span class="hljs-built_in">SetCount</span>(<span class="hljs-keyword">this</span>, WriteBatchInternal::<span class="hljs-built_in">Count</span>(<span class="hljs-keyword">this</span>) + <span class="hljs-number">1</span>);<br>  rep_.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(kTypeValue));<br>  <span class="hljs-built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);<br>  <span class="hljs-built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteBatch::Delete</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key)</span> </span>&#123;<br>  WriteBatchInternal::<span class="hljs-built_in">SetCount</span>(<span class="hljs-keyword">this</span>, WriteBatchInternal::<span class="hljs-built_in">Count</span>(<span class="hljs-keyword">this</span>) + <span class="hljs-number">1</span>);<br>  rep_.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(kTypeDeletion));<br>  <span class="hljs-built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到put和delete的实现就是先给count加一以后，将操作类型，key和value写入到rep中。</p>
<p>write_batch使用一个外部的操作类WriteBatchInternal来对write_batch进行操作，这个好处我现在还不清楚。可以看到WriteBatchInternal有许多set和get的操作。具体函数不列出了，实现逻辑比较简单。</p>
<p>在最终向memtable中写的时候需要使用到一个handle，这个在write_batch.cc中定义了MemTableInserter</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemTableInserter</span> : <span class="hljs-keyword">public</span> WriteBatch::Handler &#123;<br> <span class="hljs-keyword">public</span>:<br>  SequenceNumber sequence_;<br>  MemTable* mem_;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Put</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    mem_-&gt;<span class="hljs-built_in">Add</span>(sequence_, kTypeValue, key, value);<br>    sequence_++;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    mem_-&gt;<span class="hljs-built_in">Add</span>(sequence_, kTypeDeletion, key, <span class="hljs-built_in">Slice</span>());<br>    sequence_++;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由MemTableInserter负责将内容写到memtable中。</p>
<p>在提交一个write_batch时，首先调用的事WriteBatchInternal的InsertInto函数，可以看到他的参数是一个WriteBatch和一个memtable实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">WriteBatchInternal::InsertInto</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>&#123;<br>  MemTableInserter inserter;<br>  inserter.sequence_ = WriteBatchInternal::<span class="hljs-built_in">Sequence</span>(b);<br>  inserter.mem_ = memtable;<br>  <span class="hljs-keyword">return</span> b-&gt;<span class="hljs-built_in">Iterate</span>(&amp;inserter);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数的处理逻辑是新建一个MemTableInserter，然后将它传入到WriteBatch的Iterate函数中，平时的遍历是输出或者查找，在这里的iterator函数的作用是，遍历每一个record并且使用handle来处理这个record。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">WriteBatch::Iterate</span><span class="hljs-params">(Handler* handler)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-function">Slice <span class="hljs-title">input</span><span class="hljs-params">(rep_)</span></span>;<br>  <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt; kHeader) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;malformed WriteBatch (too small)&quot;</span>);<br>  &#125;<br><br>  input.<span class="hljs-built_in">remove_prefix</span>(kHeader);<br>  Slice key, value;<br>  <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (!input.<span class="hljs-built_in">empty</span>()) &#123;<br>    found++;<br>    <span class="hljs-type">char</span> tag = input[<span class="hljs-number">0</span>];<br>    input.<span class="hljs-built_in">remove_prefix</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">switch</span> (tag) &#123;<br>      <span class="hljs-keyword">case</span> kTypeValue:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;<br>            <span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value)) &#123;<br>          handler-&gt;<span class="hljs-built_in">Put</span>(key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;bad WriteBatch Put&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> kTypeDeletion:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key)) &#123;<br>          handler-&gt;<span class="hljs-built_in">Delete</span>(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;bad WriteBatch Delete&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;unknown WriteBatch tag&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (found != WriteBatchInternal::<span class="hljs-built_in">Count</span>(<span class="hljs-keyword">this</span>)) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;WriteBatch has wrong count&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看一下Iterate的实现，在最开始我们删掉header头部信息，然后在while循环中遍历每一个record，读出record的tag，根据不同的tag type来做出不同的处理，直到全部的record都被遍历。</p>
<p>到这里，write_batch相关的函数和实现流程就结束了，在DB的write实现中，需要调用的外部函数就是InsertInto，当判断某个write_batch可以提交时，调用InsertInto将它提交到当前的memtable中。</p>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>现在来看一下write的实现吧。话不多说，直接看代码吧</p>
<p>这个函数是比较长的，但是感觉读起来还是比较容易的。整体思路就是要把需要处理的wirte放到一个等待队列里，然后依次执行。其中每一个write都是要上锁的。函数中也使用了条件变量。</p>
<p>首先是进入函数以后要，新建一个writer，然后将给他初始化，将done设置为false。最后加入到writers等待队列中，并且在循环中使用条件变量来执行一个等待唤醒。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-function">Writer <span class="hljs-title">w</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>w.batch = updates;<br> w.sync = options.sync;<br> w.done = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br> <span class="hljs-comment">//加入一个队列</span><br> writers_.<span class="hljs-built_in">push_back</span>(&amp;w);<br> <span class="hljs-comment">//会用一个条件变量一直卡在这里</span><br> <span class="hljs-keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="hljs-built_in">front</span>()) &#123;<br>   w.cv.<span class="hljs-built_in">Wait</span>();<br> &#125;<br> <span class="hljs-keyword">if</span> (w.done) &#123;<br>   <span class="hljs-keyword">return</span> w.status;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>现在就可以进行write操作了，首先要调用MakeRoomForWrite申请写的空间，这个函数中可能会触发compaction.然后获取当前的sequence。之后可以进入到write_batch的操作了。</p>
<ul>
<li>定义WriteBatch，WriteBatchInternal以及一些参数，更新last_sequence。</li>
<li>将写操作的record添加到log中</li>
<li>调用InsertInto将write_batch写入到mem_中</li>
<li>最后再处理一些错误状况，将last_sequence写入到versions_中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// May temporarily unlock and wait.</span><br>  Status status = <span class="hljs-built_in">MakeRoomForWrite</span>(updates == <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-type">uint64_t</span> last_sequence = versions_-&gt;<span class="hljs-built_in">LastSequence</span>();<br>  Writer* last_writer = &amp;w;<br>  <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; updates != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// nullptr batch is for compactions</span><br>    WriteBatch* write_batch = <span class="hljs-built_in">BuildBatchGroup</span>(&amp;last_writer);<br>    WriteBatchInternal::<span class="hljs-built_in">SetSequence</span>(write_batch, last_sequence + <span class="hljs-number">1</span>);<br>    last_sequence += WriteBatchInternal::<span class="hljs-built_in">Count</span>(write_batch);<br><br>    <span class="hljs-comment">// Add to log and apply to memtable.  We can release the lock</span><br>    <span class="hljs-comment">// during this phase since &amp;w is currently responsible for logging</span><br>    <span class="hljs-comment">// and protects against concurrent loggers and concurrent writes</span><br>    <span class="hljs-comment">// into mem_.</span><br>    &#123;<br>      mutex_.<span class="hljs-built_in">Unlock</span>();<br>      <span class="hljs-comment">//这里是用的log 的writer 应该是要写到WAL里面</span><br>      status = log_-&gt;<span class="hljs-built_in">AddRecord</span>(WriteBatchInternal::<span class="hljs-built_in">Contents</span>(write_batch));<br>      <span class="hljs-type">bool</span> sync_error = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; options.sync) &#123;<br>        status = logfile_-&gt;<span class="hljs-built_in">Sync</span>();<br>        <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">ok</span>()) &#123;<br>          sync_error = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-comment">//调用函数处理writebatch</span><br>        status = WriteBatchInternal::<span class="hljs-built_in">InsertInto</span>(write_batch, mem_);<br>      &#125;<br>      mutex_.<span class="hljs-built_in">Lock</span>();<br>      <span class="hljs-keyword">if</span> (sync_error) &#123;<br>        <span class="hljs-comment">// The state of the log file is indeterminate: the log record we</span><br>        <span class="hljs-comment">// just added may or may not show up when the DB is re-opened.</span><br>        <span class="hljs-comment">// So we force the DB into a mode where all future writes fail.</span><br>        <span class="hljs-built_in">RecordBackgroundError</span>(status);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;<span class="hljs-built_in">Clear</span>();<br><br>    versions_-&gt;<span class="hljs-built_in">SetLastSequence</span>(last_sequence);<br>  &#125;<br><br></code></pre></td></tr></table></figure>

<p>上面再处理过一次write_batch后，要将队列中的writer都处理一下，如果发现一个writer不是刚才处理过的，那就给他设置为true，有可能是出现了错误，没有进行signal，但是在这里要处理结束。直到碰到当前的writer就跳出循环。最后的任务就是，如果队列不为空，就唤醒队头的writer。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  Writer* ready = writers_.<span class="hljs-built_in">front</span>();<br>  writers_.<span class="hljs-built_in">pop_front</span>();<br>  <span class="hljs-keyword">if</span> (ready != &amp;w) &#123;<br>    ready-&gt;status = status;<br>    ready-&gt;done = <span class="hljs-literal">true</span>;<br>    ready-&gt;cv.<span class="hljs-built_in">Signal</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (ready == last_writer) <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// Notify new head of write queue</span><br><span class="hljs-keyword">if</span> (!writers_.<span class="hljs-built_in">empty</span>()) &#123;<br>  writers_.<span class="hljs-built_in">front</span>()-&gt;cv.<span class="hljs-built_in">Signal</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>欧耶，在这里就写完了write流程了。加油加油，下一步再写一下读的操作。</p>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB-Read</title>
    <url>/2022/08/13/levelDB-Read/</url>
    <content><![CDATA[<h1 id="levelDB-read"><a href="#levelDB-read" class="headerlink" title="levelDB-read"></a>levelDB-read</h1><p>到这里就要看一下读的流程了，虽然好像读是比较简单的，但是在levelDB中，读操作Get。</p>
<p>首先要在memtable中查找，然后要在immemtable中查找。如果内存中没有的话就需要在分层管理的SSTable中进行搜索了。</p>
<p>我认为比较巧妙的是，levelDB设计了很多中iterator，所有的搜索都可以使用这些iterator进行，让代码逻辑变得非常清晰，也很优雅。希望自己有一天也能写出让人很舒服又有效的代码。</p>
<p>dbimpl中的get函数是一个read的入口，直接来看代码吧。</p>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DBImpl::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">                   std::string* value)</span> </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>上面是函数的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br> <span class="hljs-comment">//获取当前snapshot 更新到的最后的位置</span><br> SequenceNumber snapshot;<br> <span class="hljs-keyword">if</span> (options.snapshot != <span class="hljs-literal">nullptr</span>) &#123;<br>   snapshot =<br>       <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="hljs-built_in">sequence_number</span>();<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>   snapshot = versions_-&gt;<span class="hljs-built_in">LastSequence</span>();<br> &#125;<br><br> <span class="hljs-comment">//这里是读一次 就加一下reference count</span><br> MemTable* mem = mem_;<br> MemTable* imm = imm_;<br> Version* current = versions_-&gt;<span class="hljs-built_in">current</span>();<br> mem-&gt;<span class="hljs-built_in">Ref</span>();<br> <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span>) imm-&gt;<span class="hljs-built_in">Ref</span>();<br> current-&gt;<span class="hljs-built_in">Ref</span>();<br></code></pre></td></tr></table></figure>

<ul>
<li>首先要上锁，然后获取当前的snapshot 快照位置，因为在查找时是要更绝这个snapshot的值进行判断的，使用这个levelDB也可以实现快照隔离。</li>
<li>然后要读出mem，imm，current分别存放了当前的memtable，immemtable和SStable的信息。</li>
<li>之后给它们的ref都加一，可以保证在使用的时候，不会被释放掉。出现错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> have_stat_update = <span class="hljs-literal">false</span>;<br> Version::GetStats stats;<br><br> <span class="hljs-comment">// Unlock while reading from files and memtables</span><br> &#123;<br>   mutex_.<span class="hljs-built_in">Unlock</span>();<br>   <span class="hljs-comment">// First look in the memtable, then in the immutable memtable (if any).</span><br>   <span class="hljs-function">LookupKey <span class="hljs-title">lkey</span><span class="hljs-params">(key, snapshot)</span></span>;<br>   <span class="hljs-comment">//先在内存里面找 找不到就要去sstable里面找了</span><br>   <span class="hljs-keyword">if</span> (mem-&gt;<span class="hljs-built_in">Get</span>(lkey, value, &amp;s)) &#123;<br>     <span class="hljs-comment">// Done</span><br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span> &amp;&amp; imm-&gt;<span class="hljs-built_in">Get</span>(lkey, value, &amp;s)) &#123;<br>     <span class="hljs-comment">// Done</span><br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     s = current-&gt;<span class="hljs-built_in">Get</span>(options, lkey, value, &amp;stats);<br>     have_stat_update = <span class="hljs-literal">true</span>;<br>   &#125;<br>   mutex_.<span class="hljs-built_in">Lock</span>();<br> &#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>这部分逻辑是要进行查找了，先定义两个参数have_stat_update和stats，如果需要去sstable里面查找的话就要用到了，这是因为每个sstable file要进行seek的计数，如果ssek次数到达一定值会触发compaction，这里在查找了SSTable后会对seek的值进行更新。</li>
<li>在查找时是使用LookupKey，这里是levelDB定义的一些key，可以看到是根据key和snapshot得到的</li>
<li>在查找过程中，首先查找memetable，然后查找immemtable</li>
<li>如果内存中的table都没有命中，那么就需要去磁盘中的SStable中查找了，代码中的逻辑也非常清楚，查找的返回值会写入value中。</li>
</ul>
<p>这里具体的Get函数之后进行研究</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="hljs-built_in">UpdateStats</span>(stats)) &#123;<br>    <span class="hljs-built_in">MaybeScheduleCompaction</span>();<br>  &#125;<br>  mem-&gt;<span class="hljs-built_in">Unref</span>();<br>  <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span>) imm-&gt;<span class="hljs-built_in">Unref</span>();<br>  current-&gt;<span class="hljs-built_in">Unref</span>();<br>  <span class="hljs-keyword">return</span> s;<br></code></pre></td></tr></table></figure>

<ul>
<li>最后一部分代码做一下收尾的工作</li>
<li>首先看一下状态有没有改变，如果有的话就要更新一下，然后调用MaybeScheduleCompaction判断有没有可能会触发compaction</li>
<li>最后就是要把mem，imm，current的ref减一</li>
</ul>
<p>在DBimpl中可以看到，由于mem，imm，current的get函数，使得这个实现比较简单，具体的查询过程其实隐藏在了队memtable和SSTable的搜索中。下面我们就来看一下。</p>
<p>我们知道mem和imm的结构是一样的，只不过mem是可读可写的，但是imm是只读的。所以他俩的get其实是一样的</p>
<h4 id="memtable-Get"><a href="#memtable-Get" class="headerlink" title="memtable::Get"></a>memtable::Get</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MemTable::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span> </span>&#123;<br>  Slice memkey = key.<span class="hljs-built_in">memtable_key</span>();<br>  <span class="hljs-function">Table::Iterator <span class="hljs-title">iter</span><span class="hljs-params">(&amp;table_)</span></span>;<br>  iter.<span class="hljs-built_in">Seek</span>(memkey.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">if</span> (iter.<span class="hljs-built_in">Valid</span>()) &#123;<br>    <span class="hljs-comment">// entry format is:</span><br>    <span class="hljs-comment">//    klength  varint32</span><br>    <span class="hljs-comment">//    userkey  char[klength]</span><br>    <span class="hljs-comment">//    tag      uint64</span><br>    <span class="hljs-comment">//    vlength  varint32</span><br>    <span class="hljs-comment">//    value    char[vlength]</span><br>    <span class="hljs-comment">// Check that it belongs to same user key.  We do not check the</span><br>    <span class="hljs-comment">// sequence number since the Seek() call above should have skipped</span><br>    <span class="hljs-comment">// all entries with overly large sequence numbers.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* entry = iter.<span class="hljs-built_in">key</span>();<br>    <span class="hljs-type">uint32_t</span> key_length;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_ptr = <span class="hljs-built_in">GetVarint32Ptr</span>(entry, entry + <span class="hljs-number">5</span>, &amp;key_length);<br>    <span class="hljs-keyword">if</span> (comparator_.comparator.<span class="hljs-built_in">user_comparator</span>()-&gt;<span class="hljs-built_in">Compare</span>(<br>            <span class="hljs-built_in">Slice</span>(key_ptr, key_length - <span class="hljs-number">8</span>), key.<span class="hljs-built_in">user_key</span>()) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Correct user key</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tag = <span class="hljs-built_in">DecodeFixed64</span>(key_ptr + key_length - <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="hljs-number">0xff</span>)) &#123;<br>        <span class="hljs-keyword">case</span> kTypeValue: &#123;<br>          Slice v = <span class="hljs-built_in">GetLengthPrefixedSlice</span>(key_ptr + key_length);<br>          value-&gt;<span class="hljs-built_in">assign</span>(v.<span class="hljs-built_in">data</span>(), v.<span class="hljs-built_in">size</span>());<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> kTypeDeletion:<br>          *s = Status::<span class="hljs-built_in">NotFound</span>(<span class="hljs-built_in">Slice</span>());<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是完整的代码，我们可以看到，是直接使用table的iterator的seek函数进行了查找，如果iter是有效的那么说明查找成功，之后还需要对key在进行一下比对。然后根据value的类型返回结果就可以了，这里iterator的实现可以再memtable的skiplist中看到。整体这部分的代码还是比较简单的。</p>
<h3 id="SSTable-搜索"><a href="#SSTable-搜索" class="headerlink" title="SSTable 搜索"></a>SSTable 搜索</h3><p>梳理了一下在SSTable的搜索流程，先整体写一下</p>
<ol>
<li>首先要在level0中进行搜索，因为在level0里面可能会出现很多file有重叠的部分，所以要进行遍历的搜索，然后再对每一个level0的table进行查找。</li>
<li>如果level0中没有找到，那么就要依次遍历每一层1–n，在每一层中因为是有序的，所以可以使用二分查找来确定合适的SSTable，然后在SSTable中进行搜索。</li>
</ol>
<p>整体就是这样的流程，但是代码的逻辑比较复杂，但是也写的比较巧妙，现在来看一下代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span> &#123;<br>    Saver saver;<br>    GetStats* stats;<br>    <span class="hljs-type">const</span> ReadOptions* options;<br>    Slice ikey;<br>    FileMetaData* last_file_read;<br>    <span class="hljs-type">int</span> last_file_read_level;<br><br>    VersionSet* vset;<br>    Status s;<br>    <span class="hljs-type">bool</span> found;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">Match</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg, <span class="hljs-type">int</span> level, FileMetaData* f)</span> </span>&#123;<br>      State* state = <span class="hljs-built_in">reinterpret_cast</span>&lt;State*&gt;(arg);<br><br>      <span class="hljs-keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="hljs-literal">nullptr</span> &amp;&amp;<br>          state-&gt;last_file_read != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// We have had more than one seek for this read.  Charge the 1st file.</span><br>        state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;<br>        state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;<br>      &#125;<br><br>      state-&gt;last_file_read = f;<br>      state-&gt;last_file_read_level = level;<br><br>      <span class="hljs-comment">//这里这里去table里面去找</span><br>      state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;<span class="hljs-built_in">Get</span>(*state-&gt;options, f-&gt;number,<br>                                                f-&gt;file_size, state-&gt;ikey,<br>                                                &amp;state-&gt;saver, SaveValue);<br>      <span class="hljs-keyword">if</span> (!state-&gt;s.<span class="hljs-built_in">ok</span>()) &#123;<br>        state-&gt;found = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">switch</span> (state-&gt;saver.state) &#123;<br>        <span class="hljs-keyword">case</span> kNotFound:<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// Keep searching in other files</span><br>        <span class="hljs-keyword">case</span> kFound:<br>          state-&gt;found = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">case</span> kDeleted:<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">case</span> kCorrupt:<br>          state-&gt;s =<br>              Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;corrupted key for &quot;</span>, state-&gt;saver.user_key);<br>          state-&gt;found = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// Not reached. Added to avoid false compilation warnings of</span><br>      <span class="hljs-comment">// &quot;control reaches end of non-void function&quot;.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>

<p>首先是在versionset的Get中，定一个一个state结构体，里面会保存许多信息，用来搜索和做处理，最关键的是Match函数，之后这个函数会被当作一个参数去传递。就是当找到了合适的SSTable文件是，调用Match去在table中进行查找。</p>
<p>在Match函数中可以看到是调用了一个table_cache_-&gt;Get</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">TableCache::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">uint64_t</span> file_number,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">uint64_t</span> file_size, <span class="hljs-type">const</span> Slice&amp; k, <span class="hljs-type">void</span>* arg,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">void</span> (*handle_result)(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> Slice&amp;,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> Slice&amp;))</span> </span>&#123;<br>  <span class="hljs-comment">//这里要获取到这个table 将这个table读到cache中</span><br>  Cache::Handle* handle = <span class="hljs-literal">nullptr</span>;<br>  Status s = <span class="hljs-built_in">FindTable</span>(file_number, file_size, &amp;handle);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    Table* t = <span class="hljs-built_in">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="hljs-built_in">Value</span>(handle))-&gt;table;<br>    <span class="hljs-comment">//然后再congtable中进行读取</span><br>    s = t-&gt;<span class="hljs-built_in">InternalGet</span>(options, k, arg, handle_result);<br>    cache_-&gt;<span class="hljs-built_in">Release</span>(handle);<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我个人的理解是tablecache是在需要对file进行读的时候，将它读到cache中 的，可能之前他就存在在cache中，cache我没有进行深入研究过，但是理论上应该是这样。</p>
<p>这时获取了SStable的table以后就可以调用InternalGet去进行搜索了。最终的结果会在handle_result中写回去。感觉这样的封装可以学习，写的很巧妙。</p>
<p>下面来研究一下InternalGet吧，之前在SSTable的部分也没有深入read的部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Table::InternalGet</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">const</span> Slice&amp; k, <span class="hljs-type">void</span>* arg,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">void</span> (*handle_result)(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> Slice&amp;,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">const</span> Slice&amp;))</span> </span>&#123;<br>  Status s;<br>  Iterator* iiter = rep_-&gt;index_block-&gt;<span class="hljs-built_in">NewIterator</span>(rep_-&gt;options.comparator);<br>  iiter-&gt;<span class="hljs-built_in">Seek</span>(k);<br>  <span class="hljs-keyword">if</span> (iiter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>    Slice handle_value = iiter-&gt;<span class="hljs-built_in">value</span>();<br>    FilterBlockReader* filter = rep_-&gt;filter;<br>    BlockHandle handle;<br>    <span class="hljs-keyword">if</span> (filter != <span class="hljs-literal">nullptr</span> &amp;&amp; handle.<span class="hljs-built_in">DecodeFrom</span>(&amp;handle_value).<span class="hljs-built_in">ok</span>() &amp;&amp;<br>        !filter-&gt;<span class="hljs-built_in">KeyMayMatch</span>(handle.<span class="hljs-built_in">offset</span>(), k)) &#123;<br>      <span class="hljs-comment">// Not found</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Iterator* block_iter = <span class="hljs-built_in">BlockReader</span>(<span class="hljs-keyword">this</span>, options, iiter-&gt;<span class="hljs-built_in">value</span>());<br>      block_iter-&gt;<span class="hljs-built_in">Seek</span>(k);<br>      <span class="hljs-keyword">if</span> (block_iter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>        (*handle_result)(arg, block_iter-&gt;<span class="hljs-built_in">key</span>(), block_iter-&gt;<span class="hljs-built_in">value</span>());<br>      &#125;<br>      s = block_iter-&gt;<span class="hljs-built_in">status</span>();<br>      <span class="hljs-keyword">delete</span> block_iter;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    s = iiter-&gt;<span class="hljs-built_in">status</span>();<br>  &#125;<br>  <span class="hljs-keyword">delete</span> iiter;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先是使用iterator从index_block中查找合适的block</li>
<li>如果找到的话，就用FilterBlockReader来判断这个block中是否有要查找的key值，如果没有就不找了</li>
<li>但是如果key在block中的话，就使用block的iterator来查找对应的值，使用handle_result来处理结果。这个handle_result应该是SaveValue函数，用来保存结果。</li>
</ul>
<p>可以看到，整个的查找基本都是使用iterator，我感觉这是levelDB中最让我觉得优雅的地方。</p>
<p>之后我应该列一下levelDB中出现的所有iterator。</p>
<p>到现在如果在某个SSTable中找到value的话那么就可以宣告搜索结束了。</p>
<p>很明显在levelDB中的读操作要比写操作复杂很多很多，这也是LSM的一个缺点吧。读操作的性能不是很高，尤其如果需要读很多level的SSTable的话。这种情况在查找一个不存在的key的时候出现的可能性很大。</p>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>这一部分，我要总结一下我在levelDB中看到的所有的Iterator</p>
<table>
<thead>
<tr>
<th>iterator</th>
<th>所在文件</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>MemTableIterator</td>
<td>memtable.cc</td>
<td>用来对memtable和immtable进行读取</td>
</tr>
<tr>
<td>Block::Iter</td>
<td>Block.cc</td>
<td>用来对SSTable中的block中数据进行读取</td>
</tr>
<tr>
<td>MergingIterator</td>
<td>Merger.cc</td>
<td>这是一个结合的iterator，可以将很多的iterator和在一个iterator中保持有序的读取</td>
</tr>
<tr>
<td>TwoLevelIterator</td>
<td>TwoLevelIterator.cc</td>
<td>用来对SSTable进行读取，TwoLevel是因为一边读index_block，一边读data_block</td>
</tr>
<tr>
<td>LevelFileNumIterator</td>
<td>version_set.cc</td>
<td>用来读取某一个level的files</td>
</tr>
<tr>
<td>DBIter</td>
<td>Db_iter.cc</td>
<td>这个是一个整体的iterator，其中会有mem，imm的iterator和每一个level的iterator</td>
</tr>
</tbody></table>
<p>具体的实现等之后有机会再研究一下吧。这些iterator还是很有意思的。最神奇的是MergingIterator的实现，之前从来都没想过还可以这么写，里面保持了mem，imm，和多个level的iterator，然后再去实现iterator的各种函数，看的我感觉目瞪口呆，，，有点夸张。不过真的感觉levelDB的设计真的很好。代码写的也棒～</p>
]]></content>
      <tags>
        <tag>levelDB</tag>
      </tags>
  </entry>
</search>
